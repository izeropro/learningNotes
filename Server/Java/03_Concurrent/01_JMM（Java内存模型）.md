## 什么是JMM(Java Memory Model)
可以把 **JMM** 看作是 Java 定义的**并发编程相关的一组规范**，不仅**抽象了线程和主内存之间的关系**之外，其还**规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范**，其主要目的是为了简化多线程编程，增强程序可移植性的。
## 并发编程三个重要特性（JMM定义了什么）
1. 原子性
  - 一次操作或者多次操作，要么所有的操作全部都得到执行，并且不会受到任何因素的干扰而中断，要么都不执行。
  - 在 Java 中，可借助**synchronized**、**Lock**以及各种**原子类**实现原子性。  
    * synchronized 和各种 Lock 可以保证任一时刻只有一个线程访问该代码块，因此可以保障原子性
    * 原子类是利用 CAS (compare and swap) 操作（可能也会用到 volatile或者final关键字）来保证原子操作
2. 可见性
  - 当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。
  - 在 Java 中，可以借助synchronized 、**volatile** 以及各种 Lock 实现可见性
3. 有序性
  - 由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。
  - 在 Java 中，**volatile** 关键字可以禁止指令进行重排序优化
## 八种内存交互操作
1. lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。
2. read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。
3. load(加载)，作用于工作内存的变量，把read操作主存的变量放入到工作内存的变量副本中。
4. use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
5. assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。
6. store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。
7. write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
8. unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
### JMM对8种内存交互操作制定的规则
1. 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。
2. 不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。
3. 不允许线程将没有assign的数据从工作内存同步到主内存。
4. 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。
5. 一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。
6. 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。
7. 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。
8. 一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。

## volatile
学习参考：[彻底理解volatile关键字](https://www.cnblogs.com/wangwudi/p/12303772.html)
1. 内存可见性
    - 保证了不同线程对共享变量进行操作时的可见性，即一个线程修改了某个变量的值，这个新值对其他线程来说是 立即可见 的
2. 禁止指令重排序（保证有序性）
    - 为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做**指令的重排序**
    - 重排序的种类分为三种，分别是：编译器重排序，指令级并行的重排序，内存系统重排序
    - volatile禁止指令重排序的原理是什么？
      - LoadLoad 屏障：对于这样的语句Load1，LoadLoad，Load2。在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
      - StoreStore屏障：对于这样的语句Store1， StoreStore， Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
      - LoadStore 屏障：对于这样的语句Load1， LoadStore，Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
      - StoreLoad 屏障：对于这样的语句Store1， StoreLoad，Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。
3. 不保证原子性（线程不安全）

## 参考
* JMM（Java 内存模型）详解：https://javaguide.cn/java/concurrent/jmm.html